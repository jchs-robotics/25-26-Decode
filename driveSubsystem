package org.firstinspires.ftc.teamcode.components.subsystems;

import com.arcrobotics.ftclib.command.SubsystemBase;
import com.arcrobotics.ftclib.hardware.motors.Motor;
import com.arcrobotics.ftclib.hardware.sensors.IMU;
import com.qualcomm.hardware.rev.RevHubOrientationOnRobot;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.hardware.HardwareMap;
import org.firstinspires.ftc.teamcode.Constants;

public class DriveSubsystem extends SubsystemBase {

    // Motors
    private final Motor FLDrive;
    private final Motor BLDrive;
    private final Motor FRDrive;
    private final Motor BRDrive;

    // IMU
    private final IMU imu;

    // Encoder tracking
    private int FLEncoder;

    public DriveSubsystem(HardwareMap hMap) {
        // Initialize motors using FTCLib Motor wrapper
        FLDrive = new Motor(hMap, Constants.DriveMotors.FL, Motor.GoBILDA.RPM_312);
        BLDrive = new Motor(hMap, Constants.DriveMotors.BL, Motor.GoBILDA.RPM_312);
        FRDrive = new Motor(hMap, Constants.DriveMotors.FR, Motor.GoBILDA.RPM_312);
        BRDrive = new Motor(hMap, Constants.DriveMotors.BR, Motor.GoBILDA.RPM_312);

        // Reverse left motors
        FLDrive.setInverted(true);
        BLDrive.setInverted(true);

        // Brake mode
        FLDrive.setBrake(true);
        BLDrive.setBrake(true);
        FRDrive.setBrake(true);
        BRDrive.setBrake(true);

        // Initialize IMU
        imu = new IMU(hMap, Constants.IMU.NAME);

        IMU.Parameters parameters = new IMU.Parameters();
        parameters.revHubOrientationOnRobot = new RevHubOrientationOnRobot(
                RevHubOrientationOnRobot.LogoFacingDirection.UP,
                RevHubOrientationOnRobot.UsbFacingDirection.RIGHT
        );
        imu.initialize(parameters);
    }

    // Simple tank/holonomic drive
    public void drive(double FLPower, double BLPower, double FRPower, double BRPower) {
        FLDrive.set(FLPower);
        BLDrive.set(BLPower);
        FRDrive.set(FRPower);
        BRDrive.set(BRPower);
    }

    public void stop() {
        drive(0, 0, 0, 0);
    }

    // Field-oriented drive
    public void driveFieldOriented(double x, double y, double rx) {
        double heading = imu.getRobotYawPitchRollAngles().getYaw(); // Radians
        double cosA = Math.cos(-heading);
        double sinA = Math.sin(-heading);

        double rotX = x * cosA - y * sinA;
        double rotY = x * sinA + y * cosA;

        // Apply strafe correction if needed
        rotX *= Constants.DriveMultipliers.STRAFE_CORRECTION;

        double denominator = Math.max(Math.abs(rotY) + Math.abs(rotX) + Math.abs(rx), 1);

        double FLPower = (rotY + rotX + rx) / denominator;
        double BLPower = (rotY - rotX + rx) / denominator;
        double FRPower = (rotY - rotX - rx) / denominator;
        double BRPower = (rotY + rotX - rx) / denominator;

        drive(FLPower, BLPower, FRPower, BRPower);
    }

    // Encoder methods
    @Override
    public void periodic() {
        FLEncoder = FLDrive.getCurrentPosition();
    }

    public boolean isAtPosition(double target) {
        return Math.abs(FLEncoder - target) < Constants.DrivePID.TOLERANCE;
    }

    public void resetEncoders() {
        FLDrive.resetEncoder();
        BLDrive.resetEncoder();
        FRDrive.resetEncoder();
        BRDrive.resetEncoder();
    }

    public void resetYaw() {
        imu.resetYaw();
    }
}
